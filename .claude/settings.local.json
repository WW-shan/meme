{
  "permissions": {
    "allow": [
      "Skill(superpowers:brainstorming)",
      "Bash(git init)",
      "Bash(git add:*)",
      "WebSearch",
      "WebFetch(domain:github.com)",
      "Bash(curl:*)",
      "WebFetch(domain:four.meme)",
      "WebFetch(domain:bscscan.com)",
      "Bash(tree:*)",
      "Bash(chmod:*)",
      "Bash(python3:*)",
      "Bash(source:*)",
      "Bash(pip install:*)",
      "Bash(python:*)",
      "Bash(git commit:*)",
      "Bash(gtimeout:*)",
      "Bash(./start.sh)",
      "Bash(pkill:*)",
      "Skill(ralph-loop:ralph-loop:*)",
      "Bash(.venvScriptsactivate)",
      "Bash(grep:*)",
      "Bash(taskkill:*)",
      "Bash(bash:*)",
      "Bash(git push:*)",
      "Bash(git worktree list:*)",
      "Bash(tail:*)",
      "Bash(tee:*)",
      "Bash(dir:*)",
      "Bash(.venvScriptspip install:*)",
      "Bash(\".venv\\\\Scripts\\\\pip.exe\" install:*)",
      "Bash(ls:*)",
      "Read(//d/Code/meme/**)",
      "Bash(./venv/Scripts/python -m pip install:*)",
      "Bash(./venv/Scripts/python:*)",
      "Bash(git ls-tree:*)",
      "mcp__plugin_context7_context7__resolve-library-id",
      "Bash(./tools/bot_manage.sh stop)",
      "Bash(wmic process:*)",
      "Bash(tasklist:*)",
      "Bash(read_file:*)",
      "Bash(src/trader/bot.py <<'EOF'\n\"\"\"\nMeme Trading Bot \\(Paper Trading Mode\\)\nIntegrates Real-time Listener, Data Collector, and ML Models.\n\"\"\"\n\nimport asyncio\nimport logging\nimport json\nimport joblib\nimport pandas as pd\nimport numpy as np\nimport sys\nimport os\nfrom pathlib import Path\nfrom datetime import datetime\nfrom typing import Dict, Optional, List\n\n# Add project root to path \\(Fix for ModuleNotFoundError\\)\nproject_root = os.path.abspath\\(os.path.join\\(os.path.dirname\\(__file__\\), \"../../\"\\)\\)\nif project_root not in sys.path:\n    sys.path.insert\\(0, project_root\\)\n\nfrom src.core.listener import FourMemeListener\nfrom src.core.ws_manager import WSConnectionManager\nfrom src.core.trader import TradeExecutor\nfrom config.trading_config import TradingConfig\nfrom src.data.collector import DataCollector\n\n# Setup logging\nlogging.basicConfig\\(\n    level=logging.INFO,\n    format='%\\(asctime\\)s - %\\(name\\)s - %\\(levelname\\)s - %\\(message\\)s'\n\\)\nlogger = logging.getLogger\\(\"MemeBot\"\\)\n\nclass MemeBot:\n    def __init__\\(self, config: Dict\\):\n        self.config = config\n        self.w3 = config['w3']\n        self.ws_manager = config.get\\('ws_manager'\\)\n\n        # Trade Executor \\(Real Trading\\)\n        self.executor = TradeExecutor\\(self.w3\\)\n        self.trader_lock = asyncio.Lock\\(\\)\n\n        # Components\n        self.collector = DataCollector\\(output_dir=\"data/bot_data\"\\) # separate dir for bot data\n        self.listener = FourMemeListener\\(self.w3, config, ws_manager=self.ws_manager\\)\n\n        # Trading State \\(Paper Trading\\)\n        self.positions: Dict[str, Dict] = {} # token_address -> position_info\n        self.balance = config.get\\('initial_balance', 10.0\\) # BNB\n        self.active = True\n        self.trade_file = Path\\(\"data/paper_trades.jsonl\"\\)\n        self.state_file = Path\\(\"data/bot_state.json\"\\)\n\n        # --- è¿è¡Œä¼˜åŒ–å‚æ•° ---\n        self.failed_buys: Dict[str, float] = {}  # token_address -> timestamp\n        self.pending_buys: set = set\\(\\)            # tokens currently being bought\n        self.last_sync_time: float = 0            # last balance sync timestamp\n        self.sync_cooldown: int = 10              # 10s cooldown for balance sync\n        self.fail_cooldown: int = 60              # 60s cooldown for real failures\n        self.retry_cooldown: float = 0.5           # 0.5s high-frequency retry for NOT_READY\n\n        # Ensure data directory exists\n        self.trade_file.parent.mkdir\\(parents=True, exist_ok=True\\)\n\n        # Load saved state if exists\n        self._load_state\\(\\)\n\n        # Strategy Parameters \\(Sniper / Hell Mode\\)\n        self.prob_threshold = config.get\\('prob_threshold', 0.84\\) # å¼ºåˆ¶ 0.84\n        self.min_pred_return = config.get\\('min_pred_return', 50.0\\) # å¼ºåˆ¶ 50.0\n        self.stop_loss = config.get\\('stop_loss', -0.50\\) # -50%\n        self.position_size = config.get\\('position_size', 0.1\\) # 0.1 BNB\n        self.hold_time_seconds = config.get\\('hold_time_seconds', 300\\) # 5 minutes\n\n        # Load Models\n        self.clf_tier1 = None\n        self.clf_tier2 = None\n        self.clf_tier3 = None\n        self.clf = None # ä¿æŒå…¼å®¹\n        self.reg = None\n        self.meta = None\n        # åŠ¨æ€åŠ è½½ data/models ç›®å½•ä¸‹çš„æœ€æ–°æ¨¡åž‹\n        self._load_models\\(config.get\\('model_dir', 'data/models'\\)\\)\n\n        # Register Handlers\n        self._register_handlers\\(\\)\n\n        # Periodic Save\n        self.last_save_time = datetime.now\\(\\)\n\n    def _load_models\\(self, model_dir: str\\):\n        \"\"\"Load trained ML models\"\"\"\n        path = Path\\(model_dir\\)\n        if not \\(path / \"classifier_tier1.pkl\"\\).exists\\(\\) and not \\(path / \"classifier_xgb.pkl\"\\).exists\\(\\):\n            if path.exists\\(\\) and path.is_dir\\(\\):\n                subdirs = sorted\\([d for d in path.iterdir\\(\\) if d.is_dir\\(\\) and \\(\\(d / \"classifier_tier1.pkl\"\\).exists\\(\\) or \\(d / \"classifier_xgb.pkl\"\\).exists\\(\\)\\)]\\)\n                if subdirs:\n                    path = subdirs[-1]\n                else:\n                    logger.warning\\(f\"No models found in {path} or its subdirectories! Bot will only collect data.\"\\)\n                    return\n            else:\n                logger.warning\\(f\"Model path {path} does not exist! Bot will only collect data.\"\\)\n                return\n\n        logger.info\\(f\"ðŸ“‚ Loading models from: {path}\"\\)\n        try:\n            if \\(path / \"classifier_tier1.pkl\"\\).exists\\(\\):\n                self.clf_tier1 = joblib.load\\(path / \"classifier_tier1.pkl\"\\)\n                self.clf_tier2 = joblib.load\\(path / \"classifier_tier2.pkl\"\\)\n                self.clf_tier3 = joblib.load\\(path / \"classifier_tier3.pkl\"\\)\n                logger.info\\(\"Tiered Classifiers \\(1/2/3\\) loaded.\"\\)\n\n            if \\(path / \"classifier_xgb.pkl\"\\).exists\\(\\):\n                self.clf = joblib.load\\(path / \"classifier_xgb.pkl\"\\)\n\n            self.reg = joblib.load\\(path / \"regressor_lgb.pkl\"\\)\n            with open\\(path / \"model_metadata.json\", 'r'\\) as f:\n                self.meta = json.load\\(f\\)\n            logger.info\\(\"Models loaded successfully.\"\\)\n        except Exception as e:\n            logger.error\\(f\"Failed to load models: {e}\"\\)\n\n    def _register_handlers\\(self\\):\n        \"\"\"Register event handlers with listener\"\"\"\n        self.listener.register_handler\\('TokenCreate', self._on_token_create\\)\n        self.listener.register_handler\\('TokenPurchase', self._on_trade\\)\n        self.listener.register_handler\\('TokenSale', self._on_trade\\)\n        self.listener.register_handler\\('TokenPurchaseV1', self._on_trade\\)\n        self.listener.register_handler\\('TokenSaleV1', self._on_trade\\)\n        self.listener.register_handler\\('TokenPurchase2', self._on_trade\\)\n        self.listener.register_handler\\('TokenSale2', self._on_trade\\)\n        self.listener.register_handler\\('TradeStop', self._on_trade_stop\\)\n\n    async def _on_token_create\\(self, event_name, event_data\\):\n        self.collector.on_token_create\\(event_data\\)\n        args = event_data.get\\('args', {}\\)\n        symbol = args.get\\('symbol', 'UNKNOWN'\\)\n        logger.info\\(f\"ðŸ†• New Token Detected: {symbol}\"\\)\n\n    async def _on_trade\\(self, event_name, event_data\\):\n        if 'Purchase' in event_name:\n            self.collector.on_token_purchase\\(event_data\\)\n        else:\n            self.collector.on_token_sale\\(event_data\\)\n        token_address = event_data.get\\('args', {}\\).get\\('token'\\)\n        if token_address:\n            await self._process_token_logic\\(token_address\\)\n\n    async def _on_trade_stop\\(self, event_name, event_data\\):\n        self.collector.on_trade_stop\\(event_data\\)\n        token_address = event_data.get\\('args', {}\\).get\\('token'\\)\n        if token_address in self.positions:\n            logger.info\\(f\"ðŸŽ“ Token {token_address} Graduated! Closing position.\"\\)\n            await self._close_position\\(token_address, reason=\"GRADUATED\"\\)\n\n    async def _process_token_logic\\(self, token_address: str\\):\n        if \\(datetime.now\\(\\) - self.last_save_time\\).total_seconds\\(\\) > 300:\n            self.collector.save_lifecycle_data\\(\\)\n            self.last_save_time = datetime.now\\(\\)\n            # Also sync balance periodically\n            await self._sync_balance\\(\\)\n\n        lifecycle = self.collector.token_lifecycle.get\\(token_address\\)\n        if not lifecycle:\n            return\n\n        current_price = lifecycle['price_current']\n\n        if token_address in self.positions:\n            pos = self.positions[token_address]\n            entry_price = pos['entry_price']\n            pnl_pct = \\(current_price - entry_price\\) / entry_price\n            \n            # Check Stop Loss\n            if pnl_pct <= self.stop_loss:\n                await self._close_position\\(token_address, reason=\"STOP_LOSS\"\\)\n                return\n            \n            # Check Take Profit\n            if pnl_pct >= 2.0:\n                await self._close_position\\(token_address, reason=\"TAKE_PROFIT_200\"\\)\n                return\n            \n            # Check Time Exit\n            time_held = \\(datetime.now\\(\\) - pos['entry_time']\\).total_seconds\\(\\)\n            if time_held >= self.hold_time_seconds:\n                await self._close_position\\(token_address, reason=\"TIME_EXIT\"\\)\n                return\n            \n            # Log Status\n            last_log = pos.get\\('last_log_time', pos['entry_time']\\)\n            if \\(datetime.now\\(\\) - last_log\\).total_seconds\\(\\) >= 30:\n                 logger.info\\(f\"âœŠ Holding {lifecycle['symbol']}: PnL {pnl_pct:.2%} | Time: {time_held:.0f}s | Price: {current_price}\"\\)\n                 pos['last_log_time'] = datetime.now\\(\\)\n                 self._save_state\\(\\)\n            return\n\n        if token_address in self.pending_buys:\n            return\n\n        now = datetime.now\\(\\).timestamp\\(\\)\n        if token_address in self.failed_buys:\n            if now < self.failed_buys[token_address]:\n                return\n            else:\n                self.failed_buys.pop\\(token_address\\)\n\n        if not self.clf:\n            return\n\n        time_since_launch = lifecycle['last_update'] - lifecycle['create_timestamp']\n        if time_since_launch > 600:\n            return\n\n        try:\n            features_dict = self.collector._extract_features\\(\n                lifecycle,\n                lifecycle['buys'],\n                lifecycle['sells'],\n                lifecycle['last_update'],\n                future_window=300\n            \\)\n            model_features = self.meta['features']\n            X_df = pd.DataFrame\\([features_dict]\\)\n            X = X_df[model_features]\n\n            if self.clf_tier1:\n                p1 = self.clf_tier1.predict_proba\\(X\\)[0, 1]\n                p2 = self.clf_tier2.predict_proba\\(X\\)[0, 1]\n                p3 = self.clf_tier3.predict_proba\\(X\\)[0, 1]\n                prob = \\(p1 * 0.5\\) + \\(p2 * 0.3\\) + \\(p3 * 0.2\\)\n                tier_info = f\" | T1:{p1:.2f} T2:{p2:.2f} T3:{p3:.2f}\"\n            else:\n                prob = self.clf.predict_proba\\(X\\)[0, 1]\n                tier_info = \"\"\n\n            pred_return = self.reg.predict\\(X\\)[0]\n            logger.info\\(f\"ðŸ§ Analysis: {lifecycle['symbol']} | Score: {prob:.4f}{tier_info} | Ret: {pred_return:.1f}% | Age: {time_since_launch:.0f}s\"\\)\n\n            if prob >= self.prob_threshold and pred_return >= self.min_pred_return:\n                await self._open_position\\(token_address, lifecycle, prob, pred_return\\)\n\n        except Exception as e:\n            logger.error\\(f\"Prediction error for {lifecycle.get\\('symbol', 'Unknown'\\)}: {e}\", exc_info=True\\)\n\n    def _log_trade_to_file\\(self, trade_data: Dict\\):\n        try:\n            with open\\(self.trade_file, 'a', encoding='utf-8'\\) as f:\n                f.write\\(json.dumps\\(trade_data, default=str\\) + '\\\\n'\\)\n        except Exception as e:\n            logger.error\\(f\"Failed to save trade to file: {e}\"\\)\n\n    async def _sync_balance\\(self, force=False\\):\n        \"\"\"Sync balance with blockchain\"\"\"\n        if not TradingConfig.ENABLE_TRADING or not self.executor.wallet_address:\n            return\n\n        now = datetime.now\\(\\).timestamp\\(\\)\n        if not force and \\(now - self.last_sync_time < self.sync_cooldown\\):\n            return\n\n        try:\n            balance_wei = await self.w3.eth.get_balance\\(self.executor.wallet_address\\)\n            new_balance = float\\(self.w3.from_wei\\(balance_wei, 'ether'\\)\\)\n            \n            # Log significant changes\n            if abs\\(new_balance - self.balance\\) > 0.01:\n                logger.info\\(f\"ðŸ’° Balance updated: {self.balance:.4f} -> {new_balance:.4f} BNB\"\\)\n            \n            self.balance = new_balance\n            self.last_sync_time = now\n            self._save_state\\(\\)\n        except Exception as e:\n            logger.error\\(f\"Failed to sync balance: {e}\"\\)\n\n    async def _open_position\\(self, token_address, lifecycle, prob, pred_return\\):\n        \"\"\"Execute Buy\"\"\"\n        if token_address in self.pending_buys:\n            return\n\n        now = datetime.now\\(\\).timestamp\\(\\)\n        self.pending_buys.add\\(token_address\\)\n        try:\n            # Sync balance before size calculation\n            await self._sync_balance\\(force=True\\)\n            \n            if self.position_size < 1:\n                size_bnb = self.balance * self.position_size\n            else:\n                size_bnb = min\\(self.position_size, self.balance\\)\n            size_bnb = min\\(size_bnb, 0.1\\)\n\n            if size_bnb < 0.001:\n                logger.warning\\(f\"âš ï¸ Trade size {size_bnb:.4f} BNB too small, skipping.\"\\)\n                return\n\n            symbol = lifecycle['symbol']\n            price = lifecycle['price_current']\n            tx_hash = None\n            actual_size_bnb = size_bnb\n\n            if TradingConfig.ENABLE_TRADING:\n                async with self.trader_lock:\n                    # ä½¿ç”¨ TradeExecutor çš„ check_token_status è¿›è¡Œæ£€æŸ¥\n                    logger.info\\(f\"ðŸ” Checking token readiness: {symbol} \\({token_address}\\)\"\\)\n\n                    status = await self.executor.check_token_status\\(token_address\\)\n\n                    if not status['ready']:\n                        logger.warning\\(f\"âš ï¸ Token not ready: {symbol} | Reason: {status['reason']}\"\\)\n                        # æ ¹æ®ä¸åŒåŽŸå› è®¾ç½®é‡è¯•ç­–ç•¥\n                        if \"Not launched yet\" in status['reason']:\n                            self.failed_buys[token_address] = now + 1.0 # ç­‰å¾…1ç§’\n                        elif \"Price is 0\" in status['reason']:\n                            self.failed_buys[token_address] = now + 0.5\n                        else: # Graduated or Error\n                            self.failed_buys[token_address] = now + 3600\n                        return\n\n                    logger.info\\(f\"âœ… Token ready - Current price: {status['price']} \"\\)\n                    logger.info\\(f\"ðŸ’° Executing Real Buy: {symbol} \\({token_address}\\) | Size: {size_bnb:.4f} BNB\"\\)\n                    \n                    # Capture balance before trade\n                    old_balance = self.balance\n                    \n                    tx_hash = await self.executor.buy_token\\(token_address, size_bnb, expected_price=status['price']\\)\n\n                if not tx_hash:\n                    logger.warning\\(f\"âš ï¸ Real Buy failed for {symbol}. Retrying in 1.5s...\"\\)\n                    self.failed_buys[token_address] = now + 1.5\n                    return\n\n                if tx_hash == \"ALREADY_SENT\":\n                    logger.info\\(f\"â³ {symbol} transaction already in pool, waiting...\"\\)\n                    return\n\n                # Force sync balance after trade to calculate actual cost\n                await self._sync_balance\\(force=True\\)\n                actual_size_bnb = max\\(old_balance - self.balance, 0\\)\n                \n                # If balance didn't change \\(RPC lag\\), assume intended size\n                if actual_size_bnb < 0.0001:\n                    logger.warning\\(f\"âš ï¸ Balance didn't decrease after buy, using estimated size.\"\\)\n                    actual_size_bnb = size_bnb\n                    self.balance -= size_bnb # Optimistic update\n            else:\n                self.balance -= size_bnb\n\n            logger.info\\(f\"ðŸš€ BUY SIGNAL: {symbol} | Prob: {prob:.4f} | Exp.Ret: {pred_return:.1f}% | Price: {price} | Size: {actual_size_bnb:.4f} BNB\"\\)\n\n            self.positions[token_address] = {\n                'symbol': symbol,\n                'entry_price': price,\n                'entry_time': datetime.now\\(\\),\n                'size_bnb': actual_size_bnb,\n                'prob': prob,\n                'pred_return': pred_return,\n                'last_log_time': datetime.now\\(\\),\n                'tx_hash_buy': tx_hash\n            }\n            self._log_trade_to_file\\({\n                'action': 'OPEN',\n                'token': token_address,\n                'symbol': symbol,\n                'price': price,\n                'size': actual_size_bnb,\n                'time': datetime.now\\(\\),\n                'prob': prob,\n                'pred_return': pred_return,\n                'tx_hash': tx_hash,\n                'is_real_trade': TradingConfig.ENABLE_TRADING\n            }\\)\n            self._save_state\\(\\)\n        finally:\n            self.pending_buys.remove\\(token_address\\)\n\n    async def _close_position\\(self, token_address, reason\\):\n        if token_address not in self.positions:\n             return\n        pos = self.positions[token_address]\n        lifecycle = self.collector.token_lifecycle.get\\(token_address\\)\n        current_price = lifecycle['price_current'] if lifecycle else pos['entry_price']\n        tx_hash = None\n        \n        old_balance = self.balance\n        \n        if TradingConfig.ENABLE_TRADING:\n            async with self.trader_lock:\n                logger.info\\(f\"ðŸ“‰ Executing Real Sell: {pos['symbol']} \\({token_address}\\) | Reason: {reason}\"\\)\n                try:\n                    abi = [{\"constant\":True,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"type\":\"function\"}]\n                    token_contract = self.w3.eth.contract\\(address=token_address, abi=abi\\)\n                    token_balance = await token_contract.functions.balanceOf\\(self.executor.wallet_address\\).call\\(\\)\n                    if token_balance > 0:\n                        tx_hash = await self.executor.sell_token\\(token_address, token_balance\\)\n                    else:\n                        logger.warning\\(f\"âš ï¸ Token balance is 0 for {pos['symbol']}, removing position.\"\\)\n                        self.positions.pop\\(token_address\\)\n                        self._save_state\\(\\)\n                        return\n                except Exception as e:\n                    logger.error\\(f\"âŒ Error fetching balance or selling {pos['symbol']}: {e}\"\\)\n                    return\n            if not tx_hash:\n                logger.error\\(f\"âŒ Real Sell Failed or Reverted for {pos['symbol']}. Keeping position.\"\\)\n                return\n\n            # Sync balance to get net return\n            await self._sync_balance\\(force=True\\)\n            net_return_bnb = self.balance - old_balance\n        else:\n            pnl_pct = \\(current_price - pos['entry_price']\\) / pos['entry_price']\n            gross_value = pos['size_bnb'] * \\(1 + pnl_pct\\)\n            fee_rate, slippage = 0.02, 0.05\n            total_friction = fee_rate + \\(slippage * 2\\)\n            net_return_bnb = \\(gross_value * \\(1 - total_friction\\)\\) - pos['size_bnb']\n            self.balance += \\(pos['size_bnb'] + net_return_bnb\\)\n\n        self.positions.pop\\(token_address\\)\n        net_profit = net_return_bnb - pos['size_bnb'] if TradingConfig.ENABLE_TRADING else net_return_bnb\n        icon = \"âœ…\" if net_profit > 0 else \"âŒ\"\n        logger.info\\(f\"{icon} SELL {pos['symbol']} | Reason: {reason} | Net Profit: {net_profit:.4f} BNB | Bal: {self.balance:.4f} BNB\"\\)\n        self._log_trade_to_file\\({\n            'action': 'CLOSE',\n            'token': token_address,\n            'symbol': pos['symbol'],\n            'entry_price': pos['entry_price'],\n            'exit_price': current_price,\n            'net_profit': net_profit,\n            'balance': self.balance,\n            'reason': reason,\n            'time': datetime.now\\(\\),\n            'hold_duration': \\(datetime.now\\(\\) - pos['entry_time']\\).total_seconds\\(\\),\n            'tx_hash_sell': tx_hash,\n            'is_real_trade': TradingConfig.ENABLE_TRADING\n        }\\)\n        self._save_state\\(\\)\n\n    def _save_state\\(self\\):\n        try:\n            state = {\n                'balance': self.balance,\n                'positions': self.positions,\n                'last_update': datetime.now\\(\\).isoformat\\(\\)\n            }\n            # Atomic write to avoid corruption\n            temp_file = self.state_file.with_suffix\\('.tmp'\\)\n            with open\\(temp_file, 'w', encoding='utf-8'\\) as f:\n                json.dump\\(state, f, default=str, indent=2\\)\n            temp_file.replace\\(self.state_file\\)\n        except Exception as e:\n            logger.error\\(f\"Failed to save state: {e}\"\\)\n\n    def _load_state\\(self\\):\n        if not self.state_file.exists\\(\\): return\n        try:\n            with open\\(self.state_file, 'r', encoding='utf-8'\\) as f:\n                state = json.load\\(f\\)\n            \n            self.balance = float\\(state.get\\('balance', self.balance\\)\\)\n            loaded_positions = state.get\\('positions', {}\\)\n            valid_positions = {}\n            \n            for addr, pos in loaded_positions.items\\(\\):\n                try:\n                    # Validate and convert timestamps\n                    if 'entry_time' in pos:\n                        if isinstance\\(pos['entry_time'], str\\):\n                            pos['entry_time'] = datetime.fromisoformat\\(pos['entry_time']\\)\n                    else:\n                        pos['entry_time'] = datetime.now\\(\\) # Fallback\n\n                    if 'last_log_time' in pos:\n                         if isinstance\\(pos['last_log_time'], str\\):\n                            pos['last_log_time'] = datetime.fromisoformat\\(pos['last_log_time']\\)\n                    else:\n                         pos['last_log_time'] = datetime.now\\(\\)\n                    \n                    valid_positions[addr] = pos\n                except Exception as e:\n                    logger.warning\\(f\"Skipping invalid position data for {addr}: {e}\"\\)\n\n            self.positions = valid_positions\n            logger.info\\(f\"ðŸ’¾ Loaded state: {len\\(self.positions\\)} positions, Balance: {self.balance:.4f} BNB\"\\)\n        except json.JSONDecodeError:\n            logger.error\\(f\"âŒ State file corrupted. Creating backup and resetting.\"\\)\n            try:\n                self.state_file.rename\\(self.state_file.with_suffix\\('.corrupt'\\)\\)\n            except:\n                pass\n        except Exception as e:\n            logger.error\\(f\"Failed to load state: {e}\"\\)\n\n    async def sell_all_positions\\(self\\):\n        if not self.positions: return\n        logger.warning\\(f\"ðŸš¨ EMERGENCY LIQUIDATION: Selling {len\\(self.positions\\)} positions!\"\\)\n        tasks = [self._close_position\\(token, reason=\"APP_STOP_LIQUIDATION\"\\) for token in list\\(self.positions.keys\\(\\)\\)]\n        if tasks: await asyncio.gather\\(*tasks, return_exceptions=True\\)\n\n    async def start\\(self\\):\n        logger.info\\(f\"ðŸ¤– Starting MemeBot\"\\)\n        await self._sync_balance\\(force=True\\)\n        logger.info\\(f\"   Strategy: Prob > {self.prob_threshold}, Ret > {self.min_pred_return}%\"\\)\n        await self.listener.subscribe_to_events\\(\\)\n\nif __name__ == \"__main__\":\n    from web3 import AsyncWeb3\n    from dotenv import load_dotenv\n    load_dotenv\\(\\)\n    ws_url = os.getenv\\(\"BSC_WSS_URL\"\\)\n    async def main\\(\\):\n        ws_manager = WSConnectionManager\\(ws_url\\)\n        if not await ws_manager.connect\\(\\): return\n        w3 = ws_manager.get_web3\\(\\)\n        config = {\n            'w3': w3, 'ws_manager': ws_manager,\n            'contract_address': \"0x5c952063c7fc8610FFDB798152D69F0B9550762b\",\n            'model_dir': \"data/models\", 'initial_balance': 10.0,\n            'prob_threshold': 0.84, 'min_pred_return': 50.0,\n            'stop_loss': -0.50, 'hold_time_seconds': 300\n        }\n        bot = MemeBot\\(config\\)\n        try:\n            await bot.start\\(\\)\n        except asyncio.CancelledError:\n            pass\n        finally:\n            await bot.sell_all_positions\\(\\)\n    try:\n        asyncio.run\\(main\\(\\)\\)\n    except KeyboardInterrupt:\n        pass\nEOF)",
      "Bash(src/trader/bot.py:*)",
      "WebFetch(domain:raw.githubusercontent.com)"
    ]
  }
}
